# 📝 01. 원시값의 메서드

자바스크립트는 원시값(문자열, 숫자 등)을 객체처럼 다룰 수 있게 해준다. 원시값에도 객체에서처럼 메서드를 호출할 수 있다. 본격적으로 들어가기 전에 원시값 ≠ 객체 라는 것을 꼭 잊지 말자!

| **구분** | **원시값**                                                                                     | **객체**                                                                  |
| -------- | ---------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| **특징** | 원시형 값                                                                                      | 프로퍼티에 다양한 종류의 값을 저장할 수 있음                              |
| **종류** | 문자(`string`), 숫자(`number`), `bigint`, 불린(`boolean`), 심볼(`symbol`), `null`, `undefiend` | 중괄호 `{ }` 를 사용하여 만들며, 함수를 포함하여 여러 종류의 객체가 있다. |

- 객체의 장점 : 함수를 프로퍼티로 저장할 수 있다.
- 객체의 단점 : 다양한 내장 객체를 제공하고 이 객체들은 고유한 프로퍼티와 메서드를 가진다. 그러나 이런 기능을 사용하면 시스템 자원이 많이 소모된다.

```jsx
let john = {
  name: "John",
  sayHi: function () {
    alert("친구야 반갑다!");
  },
};

john.sayHi(); // 친구야 반갑다!
```

## 1-1. 원시값을 객체처럼 사용하기

### Wrapper Object란?

```jsx
let str = "문자열"; // 문자열 생성
let len = str.length; // 문자열 프로퍼티인 length 사용
```

자바스크립트에서 원시값에 대해 메서드나 프로퍼티를 호출하면 해당 원시값은 임시 객체로 변환된다. 이 임시 객체는 객체의 메서드와 프로퍼티를 사용할 수 있도록 해준다.

위 예제 코드에서 보면 문자열 리터럴 `str`은 객체가 아님에도 `length` 프로퍼티를 사용할 수 있다. 이는 프로그램이 문자열 리터럴 `str`의 프로퍼티를 참조하려고 할 때, 자바스크립트는 `new String(str)`을 호출한 것처럼 문자열 리터럴을 객체로 자동변환해주기 때문이다.

**이렇게 숫자, 문자열, 불리언 등 원시 타입의 프로퍼티에 접근하려고 할 때 생성되는 임시 객체를 래퍼 객체(Wrapper Object) 라고 한다.**

📚 참고자료
[코딩교육 티씨피스쿨](https://www.tcpschool.com/javascript/js_standard_object)

<br />

**✅ 동작 과정**

```jsx
let str = "hello";

// 원시값에 대해 메서드를 호출
console.log(str.toUpperCase()); // "HELLO"

// 실제로는 다음과 같이 동작
// 1. "hello" → 임시 String 객체로 변환
// 2. String 객체의 toUpperCase() 호출
// 3. 결과 반환 후 임시 객체 제거
```

1. 원시값 → 객체로 변환

   (ex. `“hello”.toUpperCase()` 실행하면, 문자열 “hello” 가 `String` 객체로 변환)

2. 메서드/프로퍼티 실행 : 변환된 객체에서 메서드 실행
3. 임시 객체 제거 : 메서드 실행이 끝나면 임시 객체가 제거되면서 원래의 원시값으로 돌아감

<br />

### 원시값과 래퍼 객체의 차이점 = 원시값은 불변(Immutable)하다.

- 원시값은 변경할 수 없으며, 항상 새로운 값을 생성
- 래퍼 객체는 메서드 실행을 위한 임시 객체로만 존재한다.

```jsx
let str = "hello";
str.test = 123; // 임시 String 객체에 test 프로퍼티 추가 (즉시 삭제됨)
console.log(str.test); // undefined (test는 존재하지 않음)
```

<br />

### 원시값을 객체처럼 사용하는 대표적인 메서드

1. **문자열 (String)**

   1. `.toUpperCase()`, `.toLowerCase()`

   2. `.slice()`, `.substring()`

   3. `.length`

2. **숫자 (Number)**

   1. `.toFixed()`

   2. `.toString()`

3. **불리언 (Boolean)**
   1. `.toString()`

<br />

## **1-2. `String/Number/Boolean`를 생성자로 쓰지 말자!**

원시값을 명시적으로 객체로 감싸려면 `new` 키워드를 사용해서 래퍼 객체를 생성할 수 있다. <br />
다만, 이 방법은 혼란을 줄 수 있어 권장되지 않고 잘 사용되지 않는다.

**예제**

```jsx
let str = new String("hello"); // String 객체 생성
console.log(typeof str); // "object"
console.log(str.toUpperCase()); // "HELLO"

let num = new Number(123); // Number 객체 생성
console.log(typeof num); // "object"
console.log(num.toFixed(2)); // "123.00"
```

**⚠️ 주의해야하는 이유**

```jsx
let str1 = "hello";
let str2 = new String("hello");

console.log(str1 === "hello"); // true (원시값 비교)
console.log(str2 === "hello"); // false (객체와 원시값 비교)

console.log(typeof str1); // "string"
console.log(typeof str2); // "object"
```

명시적으로 래퍼 객체를 생성하면 일반적인 원시값과 다르게 동작할 수 있으므로 사용에 주의해야 한다.

## **1-3. null , undefined 는 메서드가 없다.**

특수 자료형인 `null`, `undefined`의 원시값은 이 자료형과 연관되는 “래퍼 객체”가 없고, 메소드도 제공하지 않는다.

<br />

---

# 📝 02. 숫자형

자바스크립트는 숫자를 나타내는 두 가지 자료형을 지원한다. 일반적인 숫자는 64비트 부동소수점 형식의 IEEE-754에 저장된다. ( → 대부분 이 형식을 이용)

임의의 길이를 가진 정수는 `BigInt` 숫자로 나타낼 수 있다. 일반적인 숫자는 길이의 제약이 있기 때문에 만들어진 새로운 자료형이다. <br />주로 큰 숫자 계산이 필요한 암호화, 금융 등에서 유용하게 사용된다.

```jsx
const largeNumber = 123456789012345678901234567890n;
const anotherLargeNumber = 987654321098765432109876543210n;

console.log(largeNumber + anotherLargeNumber);
// 출력: 1111111110111111111011111111100n
```

- 숫자 뒤에 `n` 을 붙이면 `BigInt` 리터럴로 정의된다.
- `.BigInt()` 함수를 이용하여 생성할 수 있다.
- 크기에 제한 없이 정수를 정확히 표현한다.
- 소수는 지원히지 않는다.
- `Number`와 호환되지 않으며 `BigInt` 끼리만 비교가 가능하다.

  ```jsx
  // ❌ Number와 호환되지 않음
  const big = 10n;
  const num = 20;
  console.log(big + BigInt(num)); // 30n
  // console.log(big + num); // TypeError

  // 🚨 BigInt끼리만 비교 가능
  console.log(1n == 1); // true (== 사용하면 타입 강제로 변환하여 비교)
  console.log(1n === 1); // false
  ```

<br />

## 2-1. 숫자를 입력하는 다양한 방법

### 2-1-1. e 시용하여 숫자 나타내기

`e` 표기법은 **숫자가 너무 크거나 너무 작을 때 이를 간단히 표현**하기 위해 사용된다. <br />`e`는 10의 거듭제곱을 나타내며, `e` 를 기준으로 왼쪽 숫자와 오른쪽 숫자의 조합으로 크거나 작은 숫자를 계산한다.

보통 과학적 계산, 금융 애플리케이션(금액 단위 축약 표현), 물리학 등에서 사용된다.

<br />

✅ **큰 숫자 나타내기 (e 뒤에 양수)**

`e` 뒤에 **양수**를 붙이면, 해당 숫자는 **10의 거듭제곱을 곱한 값**을 나타낸다.

```jsx
let billion = 1e9; // 10억, 1과 9개의 0
console.log(billion); // 1000000000

let seventyThreeBillion = 7.3e9; // 7.3 뒤에 9개의 0
console.log(seventyThreeBillion); // 7300000000

// e 를 기준으로 왼쪽 수에 오른쪽 수 만큼 10의 거듭제곱
1e3 === 1 * 1000;
1.23e6 === 1.23 * 1000000;
```

✅ **작은 숫자 나타내기 (e 뒤에 음수)**

`e` 뒤에 음**수**를 붙이면, 해당 숫자는 **10의 거듭제곱을 나눈 값**을 나타낸다.

```jsx
let microsecond = 1e-6; // 1을 왼쪽으로 소수점 6번 이동
console.log(microsecond); // 0.000001
```

<br />

### 2-1-2. 16진수, 2진수, 8진수

1. 16진수

   - 색 나타내기, 문자를 인코딩할 때 등 다양한 곳에서 쓰인다.
   - 16진수는 `0x` 를 사용하여 짧게 표현할 수 있다.

   ```jsx
   alert(0xff); // 255
   alert(0xff); // 255 (대·소문자를 가리지 않으므로 둘 다 같은 값을 나타냅니다.)
   ```

2. 2진수와 8진수

   - `0b` 와 `0o`를 사용해 간단하게 표현한다.

   ```jsx
   let a = 0b11111111; // 255의 2진수
   let b = 0o377; // 255의 8진수

   alert(a == b); // true, 진법은 다르지만, a와 b는 같은 수
   ```

3. 이 3가지 진법 이외의 진법을 사용하려면 `parseInt` 메서드를 사용해야한다.

<br />

### 2-1-3. toString(base)

```jsx
number.toString(base);
```

`toString` 메서드는 `base`(진법)로 결과값을 **문자형으로 변환**해 반환한다.

- `base` : 숫자를 표현하는 방법, 숫자를 몇 개의 기호로 나타낼지 결정한다.
- `base` 는 2~36 사이의 정수를 지정하고 이를 통해 숫자를 2진법, 16진법 등 다양하게 변환할 수 있다.
  - 10진법(Base 10) : 0~9로 숫자를 표현 (일상에서 사용)
  - 2진법(Base 2) : 0과 1로 숫자를 표현 (컴퓨터에서 사용)

**✅ 간단 예제**

```jsx
let num = 255;

// 10진법
console.log(num.toString(10)); // "255"

// 2진법
console.log(num.toString(2)); // "11111111"

// 16진법
console.log(num.toString(16)); // "ff"

// 8진법
console.log(num.toString(8)); // "377"
```

1. **10진법 (Decimal)** : `Base 10`으로 숫자를 표현, 숫자 255는 그대로 “255”로 표현

2. **2진법 (Binary)** : `Base 2`로 숫자를 표현, **0과 1로만 구성**
3. **8진법 (Octal)** : `Base 8`로 숫자를 표현, 숫자는 **0~7로 구성**
4. **16진법 (Hexadecimal)** : `Base 16`으로 숫자를 표현, **숫자 0~9 + 문자 A~F를 사용**함 (10~15는 각각 A,B,C,D,E,F 로 표현)
5. **36진법 (Base 36)** : `Base 36`으로 숫자를 표현, **숫자 0~9 + 문자 A~Z를 사용**하여 가장 긴 표현을 제공

<br />

### 2-1-4. parseInt와 parseFloat

`parseInt`와 `parseFloat` 두 함수는 불가능할 때까지 문자열에서 숫자를 읽는다. <br />
만약 읽는 도중 오류가 발생하면 그 시점까지 읽어서 수집된 숫자를 반환한다.

**`parseInt`는 정수, `parseFloat`는 부동 소수점 숫자를 반환**한다.

```jsx
console.log(parseInt('100px')); // 100
console.log(parseFloat('12.5em') ; // 12.5

console.log(parseInt('12.3')); // 12, 정수 부분만 반환
console.log(parseFloat('12.3.4')); // 12.3, 두 번째 점에서 숫자 읽기 중단!

console.log(parseInt('a123')) // NaN -> 읽을 수 있는 숫자가 없을 때
```

<br />

**💡 parseInt(str, radix) 두 번째 인수**

```jsx
console.log(parseInt("0xff", 16)); // 255
console.log(parseInt("ff", 16)); // 255, 0x가 없어도 동작

console.log(parseInt("2n9c", 36)); // 123456
```

`radix` 에는 원하는 진수를 지정하여 사용할 수 있다. 따라서 `parseInt`를 사용하면 16진수 문자열, 2진수 문자열 등을 파싱할 수 있다.

<br />

### 2-1-5. parseInt와 toString의 관계

- `toString(base)` : 숫자를 문자열로 변환 (다양한 진법으로 표현 가능함)
- `parseInt(string, base)`: 문자열을 특정 진법의 숫자로 변환 (특정 진법을 기준으로 해석함)

```jsx
let num = 255; // 10진수 숫자

// 1. 숫자를 2진수 문자열로 변환
let binaryStr = num.toString(2);
console.log(binaryStr); // "11111111" (2진수 문자열)

// 2. 변환된 2진수 문자열을 다시 10진수 숫자로 변환
let parsedNum = parseInt(binaryStr, 2);
console.log(parsedNum); // 255 (원래 숫자와 동일)

// parseInt 동작 과정 "11111111"을 2진법으로!
"11111111" = 1 × 2⁷ + 1 × 2⁶ + 1 × 2⁵ + 1 × 2⁴ + 1 × 2³ + 1 × 2² + 1 × 2¹ + 1 × 2⁰
           = 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1
           = 255 (10진수)
```

<br />

### 2-1-6. 어림수 구하기

어림수 관련 내장 함수

- `Math.floor` : 소수점 첫째 자리에서 내림

- `Math.ceil` : 소수점 첫째 자리에서 올림
- `Math.round` : 소수점 첫째 자리에서 올림
- `Math.trunc` **\*Internet Explorer 지원 ❌** : 소수부 무시

|      | `Math.floor` | `Math.ceil` | `Math.round` | `Math.trunc` |
| ---- | ------------ | ----------- | ------------ | ------------ |
| 3.1  | 3            | 4           | 3            | 3            |
| 3.6  | 3            | 4           | 4            | 3            |
| -1.1 | -2           | -1          | -1           | -1           |
| -1.6 | -2           | -1          | -2           | -1           |

<br />

**✅ 특정 소수자리 기준으로 어림수 구하는 방법**

1. **곱하기와 나누기**

   ```jsx
   let num = 1.23456;

   console.log(Math.floor(num * 100) / 100);
   // 1.23456 -> 123.456 -> 123 -> 1.23
   ```

2. **`toFixed(n)` 메서드 사용하기**

   - `toFixed(n)` :  `Number` 객체를 주어진 `digits` 만큼의 소수점 이하 자리수를 정확하게 갖는 문자열 표현으로 반환한다.
   - 소수점 이하가 길면 숫자를 반올림하고, 짧아서 부족할 경우 뒤를 0으로 채울 수 있다.
   - 구문**:** `numObj.toFixed([digits]);`

     - `digits` : 소수점 뒤에 나타날 자릿수, 0 이상 20 이하의 값 지원하며 값을 지정하지 않으면 0을 사용한다.

     - 반환값 : 고정 소수점 표기법을 사용하여 나타낸 수를 “문자열”로 바꾼 값

     ```jsx
     function financial(x) {
       return Number.parseFloat(x).toFixed(2);
     }

     console.log(financial(123.456));
     // Expected output: "123.46"
     // -> Math.round와 유사하게 가장 가까운 값으로 올림 혹은 버림

     console.log(financial(0.004));
     // Expected output: "0.00"

     console.log(financial("1.23e+5"));
     // Expected output: "123000.00"
     // -> 소수부의 길이가 인수보다 작으면 끝에 0이 추가 (반환값이 문자열이기 떄문)
     ```

<br />

### 2-1-7. 부정확한 계산

자바스크립트에서 숫자는 64비트 부동소수점 형식에 따라 저장된다. 이 형식은 정수, 소수를 모두 표현할 수 있지만 소수점 계산에서 “정확하지 않은 결과를 초래”할 수 있다.

**✅ IEEE-754 부동 소수점 형식**

숫자는 `가수 × 2^지수`의 형태로 저장되고, 제한된 비트를 사용하기 때문에 일부 숫자는 정확하게 표현할 수 없고 근사치로 저장된다.

- 부호(Sign) : 숫자가 양수인지 음수인지 표시 (1비트)
- 지수(Exponent) : 소수점 위치를 결정 (11비트)
- 가수(Mantissa) : 숫자의 정확한 값 (52비트)

> 🤔 **왜 부정확한 계산이 될까?**
>
> : 일부 소수는 이진수로 정확히 표현되지 않아 **근사치**로 저장되고, 계산 과정에서 반올림 오차가 발생한다.
>
> 🤔 **그러면 이걸 어떻게 해결할 수 있을까?**
>
> : `toFixed`, `Math.round` 메서드로 반올림 처리 또는 정수로 변환한 후 계산한다.

**✅ 부정확한 계산 해결방법**

1. 소수점 계산 시 반올림

   ```jsx
   let result = 0.1 + 0.2;
   console.log(Number(result.toFixed(2))); // 0.3
   ```

2. 정수로 변환 후 계산

   ```jsx
   let result = (0.1 * 10 + 0.2 * 10) / 10;
   console.log(result); // 0.3
   ```

3. 계산 라이브러리 사용 (`decimal.js`, `big.js`, `math.js`)

   ```jsx
   const Decimal = require("decimal.js");
   let result = new Decimal(0.1).plus(0.2);
   console.log(result.toNumber()); // 0.3
   ```

📚 참고자료

- [자바스크립트에서의 부동소수점 연산과 정확한 계산 방법](https://f-lab.kr/insight/accurate-floating-point-calculation-in-javascript)
- [JavaScript에서 부동소수점 연산 오류 해결 방법 (decimal.js)](https://tak2k.tistory.com/83)

<br />

### 2-1-8. `isNaN`과 `isFinite`

`isNaN`과 `isFinite`는 자바스크립트에서 숫자 값의 유효성을 검사하기 위한 전역함수이다.

1. **isNaN (Not-a-Number 인지 확인)**

   역할 : 숫자가 아닌 값인지 확인하며, 숫자로 변환할 수 없는 값은 `true` 를 반환한다.

   ```jsx
   console.log(isNaN("hello")); // true (숫자로 변환 불가)
   console.log(isNaN(undefined)); // true (숫자로 변환 불가)
   console.log(isNaN(123)); // false (숫자)
   console.log(isNaN("123")); // false ("123"은 숫자로 변환 가능)
   ```

   ⚠️ `isNaN`은 숫자로 변환 가능한지 여부만 확인하기 때문에 논리적으로 예상하지 못한 결과를 반환할 수 있다. → 이를 해결하기 위해서는 `Number.isNaN`을 사용하는 것이 좋다.

   ```jsx
   console.log(isNaN(null)); // false (null은 숫자 0으로 변환 가능)
   console.log(isNaN(true)); // false (true는 숫자 1로 변환 가능)
   console.log(isNaN(NaN)); // true (NaN은 숫자로 변환 불가)

   // Number.isNaN 사용
   console.log(Number.isNaN("hello")); // false
   console.log(Number.isNaN(NaN)); // true
   ```

1. **isFinite (유한 숫자인지 확인)**

   역할 : 유한한 값의 숫자인지 확인하며, `Infinity`, `-Infinity`, `NaN`인 경우 `false`를 반환 / 다른 숫자는 `true`를 반환한다.

   ```jsx
   console.log(isFinite(123)); // true (유한한 숫자)
   console.log(isFinite("123")); // true ("123"은 숫자로 변환 가능)
   console.log(isFinite(Infinity)); // false (무한대)
   console.log(isFinite(NaN)); // false (NaN은 유한하지 않음)
   console.log(isFinite("hello")); // false ("hello"는 숫자로 변환 불가)
   ```

<br />

⚠️ `isFinite`는 숫자로 변환 가능한 값을 먼저 확인하기 때문에, 엄격하게 확인하려면 `Number.isFinite` 를 사용하는 것이 좋다.

```jsx
console.log(Number.isFinite(null)); // false
console.log(Number.isFinite(123)); // true
console.log(Number.isFinite(Infinity)); // false
```

**비교 요약**

| **특징**        | **isNaN**                         | **isFinite**                             |
| --------------- | --------------------------------- | ---------------------------------------- |
| 역할            | 숫자가 아닌 **값**인지 확인       | 값이 **유한한 숫자**인지 확인            |
| 숫자로 변환     | 값을 숫자로 변환 후 확인          | 값을 숫자로 변환 후 유한성 확인          |
| Number 버전     | `Number.isNaN`: 엄격한 `NaN` 확인 | `Number.isFinite`: 엄격한 유한 숫자 확인 |
| 예제에서의 동작 | `isNaN("hello")` → `true`         | `isFinite("123")` → `true`               |
| Infinity 처리   | Infinity는 `false`                | Infinity는 `false`                       |

<br />

---

# 📝 03. 문자열

## 3-1. 문자열의 길이 length

`length` 프로퍼티에는 문자열의 길이가 저장된다.

```jsx
console.log(`My\n`.length); // 3
```

→ `\n` 은 특수 문자 하나로 취급되기 때문에 길이가 총 3으로 출력된다.

**⭐️ `length`는 함수가 아니라 프로퍼티이다!**

`str.length` 가 아니라 `str.length()`로 문자열 길이를 알아내려고 하는데, `length`는 함수가 아니고 **숫자가 저장되는 프로퍼티**이기 때문에 **괄호 () 를 붙일 필요가 없다!**

<br />

## 3-2. 특정 글자에 접근하기

문자열 특정 위치에 접근하려면 `[pos]` 처럼 `대괄호`를 사용하거나 `str.charAt(pos)` 라는 메서드를 사용해야한다. (위치는 0부터 시작)

**⚠️ `charAt`는 하위 호환성을 위해 남아있는 메서드이기 때문에 최근에는 [pos] 와 같이 `대괄호` 방식을 사용한다.**

```jsx
let str = `Hello`;

// 첫 번째 글자
console.log(str[0]); // H
console.log(str.charAt(0)); // H

// 마지막 글자
console.log(str[str.length - 1]); // o
```

- 반환할 글자가 없는 경우
  - **대괄호** : `undefined` 반환
  - **charAt** : 빈 문자열 반환
- `for .. of`를 사용하여 반복 작업 실행하기

  ```jsx
  for (let char of "Hello") {
    console.log(char); // H,e,l,l,o (char는 순차적으로 H, e, l, l, o가 된다.)
  }
  ```

<br />

## 3-3. 문자열의 불변성

문자열은 수정할 수 없기 때문에 문자열 중간 글자 하나를 바꾸려고 하면 에러가 발생한다.

이를 해결하려면 완전히 새로운 문자열을 하나 만든 후 이 문자열을 변수에 할당하면 된다.

```jsx
let str = "Hi";

str = "h" + str[1]; // 문자열 전체를 교체함

console.log(str); // hi
```

<br />

## 3-4. 대소문자 변경하기

`toLowerCase()`, `toUpperCase()`를 사용하여 케이스 변경을 할 수 있다.

```jsx
console.log("Interface".toUpperCase()); // INTERFACE
console.log("Interface".toLowerCase()); // interface

// 글자 하나의 케이스만 변경하는 것도 가능 ✅
console.log("Interface"[0].toLowerCase()); // 'i'
```

<br />

## 3-5. 부분 문자열(substring) 찾기

### 3-5-1. str.indexOf(substr, pos) 메서드

- `str`의 `pos` 에서부터 시작해서 부분 문자열 `substr` 이 **어디에 위치하는지** 찾아준다.
- 원하는 부분의 문자열을 찾으면 **위치를 반환**, 그렇지 않으면 `-1` 을 반환한다.

```jsx
let str = "Widget with id";

console.log(str.indexOf("Widget")); // 0, str은 'Widget'으로 시작
console.log(str.indexOf("widget")); // -1, indexOf는 대·소문자를 따지므로 원하는 문자열을 찾지 못함

console.log(str.indexOf("id")); // 1, "id"는 첫 번째 위치에서 발견됨 (Widget에서 id)
```

**✅  pos를 활용한 예시**

```jsx
let str = 'Widget with id'

console.log(str.indexOf('id', 2) // 12
```

부분 문자열 `“id”`는 위치 1에서 처음 등장하는데, 두 번째 인수(pos) 에 2를 넘겨 `“id”`가 두 번째로 등장하는 위치가 어디인지 알 수 있다.

**✅ 반복문 안에서의 `indexOf()`**

: 문자열 내 부분 문자열 전체를 대상으로 무언가를 하고 싶을 때 사용하는 방법이다. <br />반복문이 하나씩 돌면서 검색 시작 위치가 갱신되어 `indexOf`가 새롭게 호출된다.

```jsx
const str = "As sly as a fox, as strong as an ox"; // 검색할 문자열
let target = "as"; // 찾으려는 부분 문자열
let pos = 0; // 검색을 시작할 위치

while (true) {
  // indexOf를 사용하여 target의 위치를 찾음
  let foundPos = str.indexOf(target, pos);

  // 더 이상 찾는 문자열이 없으면 반복문 종료
  if (foundPos == -1) break;

  console.log(`위치: ${foundPos}`);

  // 검색 위치를 갱신해 다음 검색을 이어감
  pos = foundPos + 1;
}
```

**✏️ 로직 설명**

1. `pos = 0` → `indexOf('as', 0)` 실행
   - 첫 번째 'as'의 위치: 8
2. `foundPos = 8` → `console.log('위치: 8')`
3. `pos = foundPos + 1 = 9`로 갱신

<br />

**🚨 조건문에 `indexOf` 사용 시 주의사항**

if 문에서 0을 `false` 로 간주하기 때문에 부분 문자열 여부를 검사하려면 `-1` 과 비교해야한다.

```jsx
let str = "Widget with id";

if (str.indexOf("Widget") != -1) {
  console.log("찾았다!");
}
```

<br />

### 3-5-2. includes, startsWith, endsWith

1. **`includes`**

- `str`에 부분 문자열 `substr` 여부에 따라 `true` / `false` 를 반환한다.
- 부분 문자열의 위치 정보는 필요하지 않고 **포함 여부만 알고 싶을 때** 사용
- 두 번째 인수를 넘기면 해당 위치부터 부분 문자열을 검색한다. (`indexOf` 와 동일)

```jsx
console.log("Widget with id".includes("Widget")); // true
console.log("Hello".includes("Bye")); // false

// 두 번째 인수 값 넘기기
alert("Widget".includes("id")); // true
alert("Widget".includes("id", 3)); // false, 세 번째 위치 이후엔 "id"가 없음
```

2. **`startsWith`**

- 문자열 `str` 이 특정 문자로 시작하는지 (startsWith) / 특정 문자열로 끝나는지 (endsWith) 여부를 확인할 때 사용

  ```jsx
  console.log("Widget".startsWith("Wid")); // true, "Widget"은 "Wid"로 시작
  console.log("Widget".endsWith("get")); // true, "Widget"은 "get"으로 끝
  ```

<br />

## 3-6. 부분 문자열 추출하기

### 3-6-1. slice(start [, end])

- 문자열의 `start` 부터 `end` (미포함) 을 반환한다.

```jsx
let str = "stringify";
console.log(str.slice(0, 5)); // 'strin'
console.log(str.slice(0, 1)); // 's'
```

- **두 번째 인수가 생략되면 문자열 끝까지** 반환한다.

```jsx
let str = "stringify";
console.log(str.slice(2)); // ringify, 2번째부터 끝까지
```

- `start`와 `end`가 **음수**면, 문자열 **“끝”에서부터 카운팅**을 시작한다.

```jsx
let str = "stringify";

// 끝에서 4번째부터 시작해 끝에서 1번째 위치까지
console.log(str.slice(-4, -1)); // gif
```

<br />

### 3-6-2. str.substring(start, [, end])

- `start`와 `end` 사이에 있는 문자열을 반환한다.
- `substring`은 음수 인수를 허용하지 않는다. 음수는 `0`으로 처리된다.

⭐️ **`slice`와 유사하지만 `start` 값이 `end` 보다 커도 괜찮다는 차이점이 있다.**

```jsx
let str = "stringify";

// 동일한 부분 문자열을 반환
console.log(str.substring(2, 6)); // "ring"
console.log(str.substring(6, 2)); // "ring"

// slice를 사용하면 결과가 다르다.
console.log(str.slice(2, 6)); // "ring" (같음)
console.log(str.slice(6, 2)); // 💥 "" (빈 문자열)
```

<br />

### 3-6-3. str.substr(start, [, **length**])

- `start`에서부터 시작해 `length` 개의 글자를 반환한다.
- `substr`은 끝 위치 대신에 “길이”를 기준으로 문자열을 추출한다는 점이 특징이다.

**⚠️ 거의 모든 곳에서 이 메서드가 동작하지만 브라우저 이외의 호스트 환경에서는 제대로 동작하지 않을 수 있다.**

```jsx
let str = "stringify";
console.log(str.substr(2, 4)); // ring, 두 번째부터 글자 네 개
console.log(str.substr(-4, 2)); // gi, 끝에서 네 번째 위치부터 글자 두 개
```

<br />

## 3-7. 문자열 비교하기

자바스크립트에서 문자열 비교는 알파벳 순서 또는 유니코드(UTF-16) 코드 포인트를 기준으로 이루어진다.

✅ 예제

```jsx
console.log("a" > "Z"); // true (코드 값: 'a'는 97, 'Z'는 90)
console.log("Österreich" > "Zealand"); // true ('Ö'의 코드 값이 'Z'보다 큼)
```

각 문자는 고유한 코드 값(숫자)과 매칭되며, 이 코드 값으로 크기를 비교한다.

<br />

### 3-7-1. 문자열 비교의 특징

1. 소문자는 대문자보다 크다

   UTF-16 코드 값에서 대문자가 먼저 배치되기 때문

2. 발음 구별 기호(diacritical mark)는 알파벳 순서와 다를 수 있다.

   ex) `'Ö'`의 코드 값은 일반 알파벳보다 훨씬 뒤에 위치

3. 글자 비교는 코드 값을 기준으로 함
   1. `'a'.codePointAt(0)` → 97
   2. `'Z'.codePointAt(0)` → 90

<br />

### 3-7-2. str.codePointAt(pos) / **String.fromCodePoint(code)**

1. `str.codePointAt(pos)` : `pos`에 위치한 글자의 코드를 반환

   ```jsx
   console.log("z".codePointAt(0)); // 122
   console.log("Z".codePointAt(0)); // 90
   ```

2. `String.fromCodePoint(code)`: 숫자 형식의 `code`에 대응하는 글자를 만듦

   ```jsx
   console.log(String.fromCodePoint(90)); // Z
   ```

<br />

### 🤪 어떤 메소드를 언제 사용해야하나요!?

| **메서드**      | **입출력**                       | **범위**             |
| --------------- | -------------------------------- | -------------------- |
| `codePointAt`   | 문자열 → 유니코드 코드 포인트 값 | 모든 유니코드 문자   |
| `charCodeAt`    | 문자열 → UTF-16 코드 유닛 값     | BMP(U+0000 ~ U+FFFF) |
| `fromCharCode`  | UTF-16 코드 유닛 값 → 문자열     | BMP(U+0000 ~ U+FFFF) |
| `fromCodePoint` | 유니코드 코드 포인트 값 → 문자열 | 모든 유니코드 문자   |

⭐️ **특정 문자 코드 값을 정확히 확인해야 할 때**:

- 유니코드 전체 문자 → `codePointAt`
- UTF-16 코드 유닛 값 → `charCodeAt`

⭐️ **숫자 값을 문자로 변환해야 할 때**:

- BMP(기본 다국어 평면) 문자만 처리 → `fromCharCode`
- 유니코드 전체 문자 지원 → `fromCodePoint`

<br />

### 3-7-3. ASCII와 Unicode 비교

| **특징**     | **ASCII**                  | **Unicode**                      |
| ------------ | -------------------------- | -------------------------------- |
| 지원 문자 수 | 128개 (7비트)              | 1,114,112개 (최대 21비트)        |
| 범위         | 기본 영어 문자와 특수 기호 | 전 세계 모든 문자와 기호         |
| 용도         | 영어와 간단한 표현         | 다국어 지원, 전 세계 표준 인코딩 |
| 예시         | `'A'` → 65                 | `'A'` → U+0041                   |

<br />

## 3-8. 정확한 문자열 비교

기본 비교의 문제점은 **언어별로 글자의 정렬 규칙이 다르기 때문에** 단순 코드 값 비교로는 정확한 정렬이 어렵다.

`localeCompare` 를 사용하여 브라우저에서 사용 중인 언어와 정렬 규칙을 고려해 문자열을 비교한다.

```jsx
console.log("Österreich".localeCompare("Zealand"));
// -1 (정렬 기준에 따라 'Österreich'가 더 작음)
```

<br />

### 3-8-1. localeCompare 메서드의 반환값

- 비교 결과를 나타내는 **정수**를 반환한다.
- 음수 : 첫 번째 문자열 < 두 번째 문자열
- 0 : 두 문자열이 같음
- 양수 : 첫 번째 문자열 > 두 번째 문자열

<br />

### 3-8-2. 선택 인수로 비교 옵션 설정

- 특정 언어에 맞춘 비교 기준 지정 가능
- 대소문자를 구분할지 여부를 설정할 수 있다.
- 발음 구별 기호를 구분할 수 있다. ex) `‘a’`와 `'á'`를 동일하게 취급하거나 다르게 취급하도록 설정

```jsx
let str1 = "a";
let str2 = "á";

// 대소문자 무시, 발음 구별 기호 무시
console.log(str1.localeCompare(str2, "en", { sensitivity: "base" })); // 0

// 발음 구별 기호 고려
console.log(str1.localeCompare(str2, "en", { sensitivity: "variant" })); // -1
```

<br />

---

# 📝 04. 배열

객체만으로도 다양한 작업을 할 수 있으나, 순서가 있는 컬렉션이 필요할 때가 있는데, 객체를 사용하게 되면 순서와 관련된 메서드가 없어 편리하지 않는다. 객체 자체는 순서를 고려하지 않고 만들어졌기 때문에 새로운 프로퍼티를 기존 프로퍼티 사이에 끼워넣는 작업도 불가하다.

이렇듯 순서가 있는 컬렉션을 저장할 때 쓰는 자료구조 “배열”이 필요하다.

## 4-1. 배열 선언

배열은 아래 두 문법을 사용하여 빈 배열을 만들 수 있다. 대부분 `대괄호 []` 를 사용하여 선언하며 대괄호 안에 초기 요소를 넣어주는 것도 가능하다.

```jsx
let arr = new Array();
let arr = [];
```

<br />

배열 요소의 자료형에는 제약이 없다.

```jsx
// 요소에 여러 가지 자료형이 섞여 있음
let arr = [
  "사과",
  { name: "이보라" },
  true,
  function () {
    alert("안녕하세요.");
  },
];

// 인덱스가 1인 요소(객체)의 name 프로퍼티를 출력
console.log(arr[1].name); // 이보라

// 인덱스가 3인 요소(함수)를 실행
arr[3](); // 안녕하세요.
```

<br />

✅ 각 배열 요소에는 0부터 시작하는 `index` 가 매겨져 있고 이는 배열 내 순서를 나타낸다.

```jsx
let fruits = ["사과", "오렌지", "자두"];

console.log(fruits[0]); // 사과
console.log(fruits[1]); // 오렌지
console.log(fruits[2]); // 자두
```

<br />

✅ 배열 수정 및 추가하기

```jsx
// 요소 수정하기
fruits[2] = "배"; // 배열이 ["사과", "오렌지", "배"]로 바뀜

// 배열에 새로운 요소 추가하기
fruits[3] = "레몬"; // 배열이 ["사과", "오렌지", "배", "레몬"]으로 바뀜
```

<br />

✅ 배열에 담긴 요소 개수 구하기

```jsx
let fruits = ["사과", "오렌지", "자두"];
console.log(fruits.length); // 3
```

<br />

## 4-2. 배열 메서드 pop / push / shift/ unshift

자바스크립트 배열은 큐(Queue)와 스택(Stack) 이라는 자료구조를 구현할 수 있는 기능을 제공한다.

`pop`, `push`, `shift`, `unshift` 메서드는 배열의 앞 뒤에서 요소를 추가하거나 제거한다.

### 4-2-1. pop

- 배열 끝 요소를 제거하고 그 요소를 반환
- 배열 크기 1 감소

```jsx
let fruits = ["사과", "오렌지", "배"];

let removed = fruits.pop(); // "배"를 제거하고 반환
console.log(removed); // "배"
console.log(fruits); // ["사과", "오렌지"]
```

### 4-2-2. push

- 배열의 끝 요소에 추가
- 새로운 배열 길이를 반환한다.

```jsx
let fruits = ["사과", "오렌지"];

let newLength = fruits.push("배"); // "배"를 끝에 추가
console.log(newLength); // 3
console.log(fruits); // ["사과", "오렌지", "배"]
```

### 4-2-3. shift

- 배열의 앞 요소를 제거하고 제거된 요소를 반환
- 배열의 나머지 요소들이 앞으로 이동하며, 배열의 크기가 1 감소힘

```jsx
let fruits = ["사과", "오렌지", "배"];

let removed = fruits.shift(); // "사과"를 제거하고 반환
console.log(removed); // "사과"
console.log(fruits); // ["오렌지", "배"]
```

### 4-2-4. unshift

- 배열의 앞 요소에 추가
- 추가된 후 새로운 배열 길이를 반환

```jsx
let fruits = ["오렌지", "배"];

let newLength = fruits.unshift("사과"); // "사과"를 앞에 추가
console.log(newLength); // 3
console.log(fruits); // ["사과", "오렌지", "배"]
```

<br />

`push`와 `unshift`로 여러 요소 추가하기

```jsx
let fruits = ["사과"];

fruits.push("오렌지", "배"); // 끝에 추가
console.log(fruits); // ["사과", "오렌지", "배"]

fruits.unshift("파인애플", "레몬"); // 앞에 추가
console.log(fruits); // ["파인애플", "레몬", "사과", "오렌지", "배"]
```

<br />

## 4-3. 큐(Queue) 와 스택(Stack) 에서의 활용 사례

위 4가지 메서드들을 조합하면 큐(Queue), 스택(Stack) 같은 자료구조를 쉽게 구현할 수 있다.

### 4-3-1. 큐(Queue)

- 큐(Queue)는 **선입선출(FIFO: First-In-First-Out)** 구조이다.
- `push`로 요소를 추가하고 `shift`로 요소를 제거한다.

```jsx
let queue = [];

// 요소 추가
queue.push(1);
queue.push(2);
queue.push(3);
console.log(queue); // [1, 2, 3]

// 요소 제거
console.log(queue.shift()); // 1
console.log(queue); // [2, 3]
```

### 4-3-2. 스택(Stack)

- 스택은 **후입선출(LIFO: Last-In-First-Out)** 구조이다.
- `push`로 요소를 추가하고 `pop`으로 요소를 제거한다.

```jsx
let stack = [];

// 요소 추가
stack.push(1);
stack.push(2);
stack.push(3);
console.log(stack); // [1, 2, 3]

// 요소 제거
console.log(stack.pop()); // 3
console.log(stack); // [1, 2]
```

<br />

## 4-4. 배열의 내부 동작 원리

배열은 자바스크립트에서 **특수한 객체**로, 숫자형 `키(인덱스)`를 사용해 요소를 관리한다. 객체와 마찬가지로 프로퍼티를 추가 및 수정할 수 있지만, 배열 고유의 순서가 있는 자료구조로 사용할 때 가장 효율적이다.

**✅ 배열과 객체의 차이**

| **특징**  | **배열**                          | **객체**                      |
| --------- | --------------------------------- | ----------------------------- |
| 키        | 숫자형 인덱스                     | 문자열 or 심볼                |
| 순서 보장 | 있음                              | 없음                          |
| 최적화    | 순차적 데이터 저장에 최적화       | 일반적인 데이터 저장에 최적화 |
| 메서드    | `push`, `pop`, `shift`, `unshift` | 직접 구현 필요                |

### 4-4-1. 배열 동작 예시

```jsx
let fruits = ["바나나"];
let arr = fruits; // 참조를 복사

arr.push("배"); // 원래 배열(fruits)에 영향을 줌

console.log(fruits); // ["바나나", "배"]
```

배열은 참조로 복사된다.

`arr`와 `fruits` 는 같은 배열을 참조하기 때문에 한쪽에서 변경하면 다른 쪽에도 영향을 미친다.

<br />

## 4-5. 성능

### **4-5-1. push와 pop가 빠른 이유**

- 배열 끝에서 작업이 이루어지기 때문에 다른 요소의 인덱스를 이동시키지 않는다.
- `push`: 배열 끝에 요소를 추가
- `pop`: 배열 끝 요소를 제거

```jsx
let fruits = ["바나나", "배"];
fruits.pop(); // "배" 제거
console.log(fruits); // ["바나나"]
```

### **4-5-2. shift와 unshift가 느린 이유**

- 요소 이동이 필요하므로 작업 시간이 **배열 길이에 비례(O(n))하다.**
- `shift`: 배열의 맨 앞 요소를 제거 → **모든 요소를 왼쪽으로 이동**
- `unshift`: 배열 맨 앞에 요소를 추가 → **모든 요소를 오른쪽으로 이동**

```jsx
let fruits = ["사과", "바나나", "배"];
fruits.shift(); // "사과" 제거
console.log(fruits); // ["바나나", "배"]
```

![배열 성능 설명_대지 1](https://github.com/user-attachments/assets/a13421bf-988d-4712-a6c2-ea476ea0dff4)

<br />

### 4-5-3. 잘못된 배열 사용

배열을 순서 있는 데이터로 사용하지 않으면 최적화가 비활성화되어 성능 저하가 발생한다.

```jsx
let fruits = [];
fruits[99999] = "배"; // 비어 있는 인덱스가 많음 → 일반 객체처럼 동작
fruits.age = 25; // 숫자형 키가 아닌 프로퍼티 추가
```

- 빠른 연산 이점 무력화
- 순서가 중요하지 않은 데이터라면 일반 객체 `{}` 를 사용하자

<br />

## 4-6. 반복문

### 4-6-1. for 반복문

`for` 문은 배열을 순회할 때 쓰는 방법으로 순회 시 `인덱스` 를 사용한다.

```jsx
let arr = ["사과", "오렌지", "배"];

for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
```

### 4-6-2. for … of

`for … of` 를 사용하면 현재 요소의 값만! 얻을 수 있다.

```jsx
let fruits = ["사과", "오렌지", "자두"];

// 배열 요소를 대상으로 반복 작업을 수행
for (let fruit of fruits) {
  console.log(fruit);
}
```

### 4-6-3. for … in

배열은 객체형에 속하기 때문에 `for … in` 을 사용하는 것도 가능하다.

```jsx
let arr = ["사과", "오렌지", "배"];

for (let key in arr) {
  console.log(arr[key]); // 사과, 오렌지, 배
}
```

⚠️ **`for … in` 사용시 주의할 점**

- `for … in` 은 모든 프로퍼티를 대상으로 순회하기 때문에 키가 숫자가 아닌 프로퍼티도 순회 대상에 포함된다.
- `for … in` 반복문은 객체와 함꼐 사용할 때 최적화 되어 있기 때문에 배열에 사용하면 객체에 사용했을 때보다 상당히 느리다.

<br />

## 4-7. length 프로퍼티

배열에 조작을 가하면 `length` 프로퍼티는 자동으로 갱신된다. `length` 프로퍼티는 배열 내 요소의 개수가 아니라 가장 큰 인덱스에 1을 더한 값이다.

**🚨 이따구로 쓰지 마세욧!**

```jsx
let fruits = [];
fruits[123] = "사과";

console.log(fruits.length); // 124
```

`length` 프로퍼티는 쓰기가 가능하다는 특징을 가지고 있는데, 수동으로 값을 증가하면 아무 일도 일어나지 않지만 **감소시킬 경우 배열이 잘리게 된다. 이렇게 잘린 배열은 다시 되돌릴 수 없다!**

```jsx
let arr = [1, 2, 3, 4, 5];

arr.length = 2; // 요소 2개만 남기고 자르기
console.log(arr); // [1, 2]

arr.length = 5; // 본래 길이로 되돌리기
console.log(arr[3]); // undefined: 삭제된 기존 요소들이 복구되지 않는다.
```

<br />

## 4-8. new Array( )

대괄호를 사용하여 배열을 만들면 더 짧은 문법으로 배열을 만들 수 있어 비교적 잘 사용하지 않는 편이다.

⚠️ 하나의 숫자형 인수를 전달한 경우 → 전달된 숫자는 배열의 길이(`length`)로 설정된다!

```jsx
let arr = new Array(3);
console.log(arr); // [empty × 3] (요소가 없는 빈 배열)
console.log(arr.length); // 3
console.log(arr[0]); // undefined
```

✅ 이러한 혼란을 방지하려면 대괄호를 사용하거나 명시적으로 배열 생성 메서드(`Array.of`)를 사용해야한다.

```jsx
// 올바른 방법
let arr1 = [2];
let arr2 = Array.of(2);

console.log(arr1); // [2]
console.log(arr2); // [2]
```

<br />

## 4-9. toString( )

`toString` 메서드를 호출하면 쉼표로 구분한 문자열이 반환된다.

```jsx
let arr = [1, 2, 3];

console.log(arr); // 1,2,3
console.log(String(arr) === "1,2,3"); // true
```

배열에는 `Symbol`, `toPrimitive`, `valueOf` 메서드가 없다. 따라서 문자열로의 형 변환이 일어나 아래 코드처럼 값이 변환된다.

이항 덧셈 연산자 `"+"`는 피연산자 중 하나가 문자열인 경우 나머지 피연산자도 문자열로 변환하기 때문에 위와 동일하게 동작한다.

```jsx
// [] 를 사용하여 형 변환
console.log([] + 1); // "1"
console.log([1] + 1); // "11"
console.log([1, 2] + 1); // "1,21"

// 이항 덧셈 연산자
console.log("" + 1); // "1"
console.log("1" + 1); // "11"
console.log("1,2" + 1); // "1,21"
```

<br />

---

# 📝 05. 배열과 메서드

## 5-1. 요소 추가 / 삭제 메서드

### 5-1-1. splice(pos, deleteCount, ...items)

: 배열에서 pos 위치부터 deleteCount 개의 요소를 제거하거나, 제거된 자리에 items를 추가한다.

```jsx
let fruits = ["사과", "배", "포도"];
fruits.splice(1, 1, "귤"); // 1번 인덱스부터 1개 제거 후 "귤" 추가
console.log(fruits); // ["사과", "귤", "포도"]
```

<br />

## 5-2. 탐색 및 조회 메서드

### 5-2-1. indexOf(item, pos)

: 배열에서 `item`의 **첫 번째 등장 위치**를 반환. 없으면 `-1`

```jsx
let fruits = ["사과", "배", "포도", "배"];
console.log(fruits.indexOf("배")); // 1
```

### 5-2-2. lastIndexOf(item, from)

: 배열에서 `item`의 마지막으로 등장한 인덱스 반환. 없으면 `-1`

```jsx
let arr = ["a", "b", "a", "c", "a"];
console.log(arr.lastIndexOf("a")); // 4 (마지막 "a"의 인덱스)
console.log(arr.lastIndexOf("a", 2)); // 2 (2번 인덱스부터 왼쪽 검색)
console.log(arr.lastIndexOf("z")); // -1 ("z"는 없음)
```

### 5-2-3. includes(item)

: 배열에 `item`이 있으면 `true`, 없으면 `false`

```jsx
console.log(fruits.includes("포도")); // true
console.log(fruits.includes("바나나")); // false
```

### 5-2-4. find(func)

: 조건(`func`)을 만족하는 첫 번째 요소를 반환

```jsx
let numbers = [1, 2, 3, 4];
let found = numbers.find((num) => num > 2);
console.log(found); // 3
```

### 5-2-5. findIndex(func)

: `func` 조건을 만족하는 첫 번째 요소의 인덱스를 반환. 없으면 `-1`

```jsx
let numbers = [5, 12, 8, 130, 44];
let index = numbers.findIndex((num) => num > 10);
console.log(index); // 1 (12는 인덱스 1에 있음)
```

### 5-2-6. filter

: 배열의 모든 요소에 대해 `func` 조건을 만족하는 요소들만 모아 새로운 배열을 반환

⭐️ `filter`는 `find` 와 유사한 문법을 가졌지만, **`find` 메서드**는 함수의 반환 값을 `true` 로 만드는 **하나의 요소**를 찾는다. 조건을 충족하는 요소가 **여러 개라면 `filter` 메서드를 사용**한다.

```jsx
let numbers = [5, 12, 8, 130, 44];
let filtered = numbers.filter((num) => num > 10);
console.log(filtered); // [12, 130, 44]
```

### 5-2-7. some(func) / every(func)

- `some(func)` : 하나라도 조건을 만족하면 `true` 반환
- `every(func)` : 모든 요소가 조건을 만족하면 `true` 반환

```jsx
// 1. some
console.log(numbers.some((num) => num > 3)); // true

// 2. every
console.log(numbers.every((num) => num > 0)); // true
```

<br />

## 5-3. 배열 순회 메서드

### forEach(func)

: 모든 요소에 대해 `func` 를 호출하며 반환값은 없음

```jsx
numbers.forEach((num) => console.log(num)); // 1, 2, 3, 4
```

<br />

## 5-4. 배열 변형 메서드

### 5-4-1. map(func)

: 모든 요소에 `func` 를 적용해 “ 새 배열 “ 을 만듦

```jsx
let squared = numbers.map((num) => num ** 2);
console.log(squared); // [1, 4, 9, 16]
```

### 5-4-2. sort(func)

: 배열을 정렬

```jsx
let numbers = [10, 5, 20, 15];
numbers.sort((a, b) => a - b); // 오름차순 정렬
console.log(numbers); // [5, 10, 15, 20]

numbers.sort((a, b) => b - a); // 내림차순 정렬
console.log(numbers); // [20, 15, 10, 5]
```

**✏️ 작동 원리**

- `func(a, b)`의 반환값:
  - 음수: `a`가 `b`보다 앞에 위치
  - 0: 순서 변경 없음
  - 양수: `b`가 `a`보다 앞에 위치

### 5-4-3. reduce(func, initial)

: 배열을 순회하며 누적 값을 계산

```jsx
// 1. 합계 계산
let numbers = [1, 2, 3, 4];
let sum = numbers.reduce((acc, curr) => acc + curr, 0); // 초기값 0
console.log(sum); // 10

// 2. 중첩 배열 평탄화
let nested = [[1, 2], [3, 4], [5]];
let flat = nested.reduce((acc, curr) => acc.concat(curr), []);
console.log(flat); // [1, 2, 3, 4, 5]

// 3. 최댓값 찾기
let numbers = [10, 5, 20, 15];
let max = numbers.reduce((acc, curr) => (acc > curr ? acc : curr), 0);
console.log(max); // 20
```

`func(acc, curr, index, array)`:

- `acc`: 누적 값
- `curr`: 현재 요소
- `index`: 현재 인덱스
- `array`: 원본 배열

### 5-4-4. reduceRight(func, initial)

: 배열의 **오른쪽에서 왼쪽**으로 요소를 순회하며 `func`을 호출 (`reduce`와 유사하지만 순회 방향이 반대)

```jsx
let arr = [1, 2, 3, 4];
let result = arr.reduceRight((acc, curr) => acc + curr, 0);
console.log(result); // 10 (4 + 3 + 2 + 1)
```

### 5-4-5. split과 join

- **`split`**: 문자열을 특정 구분자(delimiter)로 나누어 배열로 반환
- **`join`**: 배열을 특정 구분자로 연결해 문자열로 반환

```jsx
// split
let str = "apple,banana,orange";
let arr = str.split(",");
console.log(arr); // ["apple", "banana", "orange"]

// join
let joined = arr.join(" | ");
console.log(joined); // "apple | banana | orange"
```

<br />

## 5-5. 배열 메서드와 thisArg

### 5-5-1. thisArg

: 메서드(`map`, `forEach`, `filter`, 등)에 `this`로 사용할 값을 설정

`thisArg`는 `func`의 `this`가 된다.

```jsx
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg는 선택적으로 사용할 수 있는 마지막 인수
```

✅ **예시 코드**

```jsx
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  },
};

let users = [{ age: 16 }, { age: 20 }, { age: 23 }, { age: 30 }];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

console.log(soldiers.length); // 2
console.log(soldiers[0].age); // 20
console.log(soldiers[1].age); // 23
```

`users.filter(user => army.canJoin(user))`를 사용하면 `users.filter(army.canJoin, army)`를 대체할 수 있긴 한데 `thisArg`를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용된다.

<br />

## 5-6. 기타 메서드

### 5-6-1. slice(start, end)

: 배열의 일부분을 복사해 새로운 배열 생성

```jsx
let sliced = fruits.slice(1, 2);
console.log(sliced); // ["배"]
```

### 5-6-2. concat(…items)

: 배열의 모든 요소와 `items`를 병합해 새로운 배열 생성

```jsx
let newFruits = fruits.concat(["바나나", "귤"]);
console.log(newFruits); // ["사과", "배", "포도", "바나나", "귤"]
```

<br />

## 5-7. 심화 메서드

### 5-7-1. fill(value, start, end)

: 배열의 특정 구간을 `value`로 채움

```jsx
let filled = new Array(5).fill(0, 1, 4);
console.log(filled); // [empty × 1, 0, 0, 0, empty × 1]
```

### 5-7-2. copyWithin(**target, start, end)**

: 배열의 특정 구간을 복사해 **`target` 위치에 덮어쓰기**

```jsx
let arr = [1, 2, 3, 4];
arr.copyWithin(0, 2, 4); // 2번부터 4번 앞까지 복사해 0번에 덮어씀
console.log(arr); // [3, 4, 3, 4]
```

<br />

---

# 📝 06. iterable 객체

- `Iterable` 객체는 자바스크립트에서 **반복 가능한 객체**를 의미한다.
- `for … of` 반복문과 함께 사용될 수 있는 객체를 `Iterable` 이라고 한다.
- 배열, 문자열 , `Map`, `Set` 등 모두 기본적으로 `Iterable` 이다.

## 6-1. Symbol.iterator

`Iterable` 객체는 `Symbol.iterator` 메서드를 가지고 있다. 이 메서드는 객체를 반복할 때 호출되고 `Iterator` 객체를 반환한다.

### Iterator 객체란?

- `Iterator`는 `next()`메서드를 가지고 있는 객체이다.
- `next()` 메서드는 반복할 때마다 다음 값을 반환하고, `done` 속성으로 반복이 끝났는지를 표시한다.

**✅ 문자열과 `for…of`**

```jsx
let str = "Hello";

// 문자열을 for...of로 반복
for (let char of str) {
  console.log(char); // "H", "e", "l", "l", "o"
}
```

문자열은 기본적으로 `Iterable` 이다.

**✅ Symbol.iterator 명시적으로 사용하기**

```jsx
let str = "Hello";
let iterator = str[Symbol.iterator]();

console.log(iterator.next()); // { value: "H", done: false }
console.log(iterator.next()); // { value: "e", done: false }
console.log(iterator.next()); // { value: "l", done: false }
console.log(iterator.next()); // { value: "l", done: false }
console.log(iterator.next()); // { value: "o", done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

`Symbol.iterator`를 직접 호출해 `Iterator` 객체를 얻을 수 있다.

<br />

## 6-2. 이터러블과 유사 배열

- 이터러블(iterable) : `Symbol.iterator` 가 구현된 객체
- 유사 배열(array-like) : 인덱스와 length 프로퍼티가 있어서 배열처럼 보이는 객체

**⭐️ 이터러블 객체 ≠ 유사 배열 객체**

✅ 유사배열 객체이지만 이터러블 객체가 아닌 경우

```jsx
let arrayLike = {
  // ⭐️ 인덱스와 length프로퍼티가 있음 => 유사 배열
  0: "Hello",
  1: "World",
  length: 2,
};

// Symbol.iterator가 없으므로 에러 발생
for (let item of arrayLike) {
}
```

⚠️ **이터러블과 유사배열은 배열이 아니기 때문에 `push`, `pop` 등의 배열 메서드를 지원하지 않는다.**

→ `Array.from` 범용 메서드를 사용하면 배열 메서드를 적용할 수 있다!

<br />

## 6-3. Array.from

- `Array.from` 은 Iterable 객체를 배열로 변환한다.
- 문자열, Set, Map 등도 `Array.from` 을 사용하여 배열로 변환할 수 있다.
- ES6에서 도입된 기능으로, 배열로 변환이 필요한 다양한 상황에서 유용하게 사용할 수 있다.

### 6-3-1. 기본 문법

```jsx
Array.from(arrayLike, mapFunction?, thisArg?)
```

- `arrayLike`: 변환하고자 하는 유사 배열 객체 또는 `Iterable` 객체
- `mapFunction`: (선택적) 배열 요소 각각에 적용할 매핑 함수
- `thisArg`: (선택적) `mapFunction` 내부에서 사용할 `this` 값

### 6-3-2. 주요 사용 사례

✅ **유사 배열 객체를 배열로 변환**

```jsx
// 유사 배열 객체
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2,
};

let arr = Array.from(arrayLike);
console.log(arr); // ["Hello", "World"]
console.log(Array.isArray(arr)); // true
```

✅ **문자열을 배열로 변환**

```jsx
// 문자열을 배열로 변환
let str = "Hello";
let arr = Array.from(str);

console.log(arr); // ["H", "e", "l", "l", "o"]
```

**✏️ 코드 진행 과정**

1. `let arr = Array.from(str);` 이 부분에서 `Array.from`은 객체를 받아 이터러블인지, 유사배열인지 조사한다.
2. 넘겨 받은 인수가 이터러블이거나 유사배열인 경우 새로운 배열을 만든다.
3. 객체의 모든 요소를 새롭게 만든 배열로 복사한다.

✅ `Set`이나 `Map` 같은 `Iterable` 객체를 배열로 변환

```jsx
// Set
let set = new Set([1, 2, 3]);
let arrFromSet = Array.from(set);
console.log(arrFromSet); // [1, 2, 3]

// Map
let map = new Map([
  [1, "a"],
  [2, "b"],
]);
let arrFromMap = Array.from(map);
console.log(arrFromMap); // [[1, "a"], [2, "b"]]
```

✅ **매핑 함수와 함께 사용하기**

```jsx
let numbers = [1, 2, 3, 4];

// 각 요소를 제곱한 배열 생성
let squared = Array.from(numbers, (num) => num ** 2);
console.log(squared); // [1, 4, 9, 16]
```

✅ **`thisArg`와 함께 사용하기**

```jsx
let obj = { multiplier: 2 };

let numbers = [1, 2, 3];
let doubled = Array.from(
  numbers,
  function (num) {
    return num * this.multiplier;
  },
  obj
); // obj를 this로 설정

console.log(doubled); // [2, 4, 6]
```

📚 참고자료
[Array.from() - JavaScript | MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
